// Reference Noise
// 
// Generates noise of different kinds to use as mixing reference.
// 
// It's an age-old audio engineer's trick to use pink noise as a
// reference signal for mixing. The spectrum of pink noise isn't
// an accurate reference to human hearing though, much rather an
// approximation and a workaround.
// 
// By examining the spectral images of existing songs and mixes,
// and applying a few filtering stages to a signal of basic pink
// noise, the approximated workaround curve of pink noise can be
// "bent" into much more useful reference signals.
//
// That's what this thing is. I analyzed a wide variety of songs
// from various styles and eras, and created a list of filtering
// profiles that turn primitive pink noise into useful reference
// signals.
//
// Run the output of this plugin into the sidechain/key input of
// your favorite spectrum analyzer, if it has a sidechain input,
// and try to mix your tracks to approximate its spectral curve.
// 
// author: chokehold
// url:    https://github.com/chkhld/jsfx/
// tags:   utility noise mastering analysis reference spectrum
// Modifications by RAMman 
// Added RIAA EQ and set output levels for each EQ to -20dB RMS
//
desc:Reference Noise

slider1:preset=2<0,3,1{White Noise,Pink Noise,RIAA}>Noise Profile

out_pin:Left
out_pin:Right

@init
  
  // State memory for noise generation
  noiseState = 0;
  
  // Preset switching state memory
  lastPreset = -1;
  
  // Variable noise gain adjustment factor
  gainAdjust = 1.0;
  
  // Converts dB values to float gain factors
  function dBToGain (decibels) (pow(10, decibels * 0.05));
  
  // EQ CLASSES
  //
  // Implemented after Andrew Simper's State Variable Filter paper.
  // https://cytomic.com/files/dsp/SvfLinearTrapOptimised2.pdf
  //
  function eqTick (sample) instance (v1, v2, v3, ic1eq, ic2eq)
  (
    v3 = sample - ic2eq;
    v1 = this.a1 * ic1eq + this.a2 * v3;
    v2 = ic2eq + this.a2 * ic1eq + this.a3 * v3;
    ic1eq = 2.0 * v1 - ic1eq; ic2eq = 2.0 * v2 - ic2eq;
    (this.m0 * sample + this.m1 * v1 + this.m2 * v2);
  );
  //
  // Peak EQ band
  //
  function eqPK (SR, Hz, Q, dB) instance (a1, a2, a3, m0, m1, m2) local (A, g, k)
  (
    A = pow(10.0, dB * 0.025); g = tan($PI * (Hz / SR)); k = 1.0 / (Q * A);
    a1 = 1.0 / (1.0 + g * (g + k)); a2 = a1 * g; a3 = a2 * g;
    m0 = 1.0; m1 = k * ((A * A) - 1.0); m2 = 0.0;
  );
  //
  // High pass filter
  //
  function eqHP (SR, Hz, Q) instance (a1, a2, a3, m0, m1, m2) local (g, k)
  (
    g = tan($PI * (Hz / SR)); k = 1.0 / Q;
    a1 = 1.0 / (1.0 + g * (g + k)); a2 = a1 * g; a3 = a2 * g;
    m0 = 1.0; m1 = -k; m2 = -1.0;
  );
  //
  // Low pass filter
  //
  function eqLP (SR, Hz, Q) instance (a1, a2, a3, m0, m1, m2) local (g, k)
  (
    g = tan($PI * (Hz / SR)); k = 1.0 / Q;
    a1 = 1.0 / (1.0 + g * (g + k)); a2 = a1 * g; a3 = a2 * g;
    m0 = 0.0; m1 = 0.0; m2 = 1.0;
  );
  //
  // Low shelf filter
  //
  function eqLS (SR, Hz, Q, dB) instance (a1, a2, a3, m0, m1, m2) local (A, g, k)
  (
    A = pow(10.0, dB * 0.025); g = tan($PI * (Hz / SR)); k = 1.0 / Q;
    a1 = 1.0 / (1.0 + g * (g + k)); a2 = a1 * g; a3 = a2 * g;
    m0 = 1.0; m1 = k * (A - 1.0); m2 = sqr(A) - 1.0;
  );
  //
  // High shelf filter
  //
  function eqHS (SR, Hz, Q, dB) instance (a1, a2, a3, m0, m1, m2) local (A, g, k)
  (
    A = pow(10.0, dB * 0.025); g = tan($PI * (Hz / SR)); k = 1.0 / Q;
    a1 = 1.0 / (1.0 + g * (g + k)); a2 = a1 * g; a3 = a2 * g;
    m0 = sqr(A); m1 = k * (1.0 - A) * A; m2 = 1.0 - m0;
  );
  //
  // Dummy pass-through non-filter
  //
  function eqDM () instance (a1, a2, a3, m0, m1, m2)
  (
    m0 = 1; m1 = 0; m2 = 0;
  );
  
  // WHITE NOISE
  //
  // Randomized sample values between -1 and +1
  // 
  function tickWhite ()
  (
    ((rand() * 2)-1);
  );
  
  // PINK NOISE
  //
  // "Warm" sounding, volume falls off at -3 dBfs per octave across the
  // spectrum. Often said to be similar to the optimal mix balance, and
  // to be generally pleasing to the human ear.
  //
  // Implemented after Larry Trammell's "newpink" method:
  // http://www.ridgerat-tech.us/tech/newpink.htm
  //
  function tickPink () local (break, sample)
  (
    // Randomized sample in range [0,1]
    sample = rand();
    
    break = 0;
    
    break == 0 && sample <= 0.00198 ? (noiseState[1] = tickWhite() * 3.8024; break = 1);
    break == 0 && sample <= 0.01478 ? (noiseState[2] = tickWhite() * 2.9694; break = 1);
    break == 0 && sample <= 0.06378 ? (noiseState[3] = tickWhite() * 2.5970; break = 1);
    break == 0 && sample <= 0.23378 ? (noiseState[4] = tickWhite() * 3.0870; break = 1);
    break == 0 && sample <= 0.91578 ? (noiseState[5] = tickWhite() * 3.4006; break = 1);
    
    // Noise sample accumulation
    noiseState[0] = 0;
    noiseState[0] += noiseState[1];
    noiseState[0] += noiseState[2];
    noiseState[0] += noiseState[3];
    noiseState[0] += noiseState[4];
    noiseState[0] += noiseState[5];
    
    // -24 dB gain adjustment
    noiseState[0] *= 0.06309573445;
  );
  
  // FILTERED NOISE
  // 
  // Generates a pink noise sample and applies filters to it in order
  // to "bend" its curve towards various musical spectral profiles.
  // 
  function tickFiltered () local (noise)
  (
    // Get a pink noise sample to start with
    noise = tickPink();
    
    // Run the filters over the pink noise sample
    noise = filter1.eqTick(noise);
    noise = filter2.eqTick(noise);
    noise = filter3.eqTick(noise);
    noise = filter4.eqTick(noise);
    noise = filter5.eqTick(noise);
    
    // Return the filtered sample
    noise;
  );


  
  // If a different preset was selected
//preset != lastPreset ?
  1 ?
  (
    // White and pink noises
    preset == 0 ? gainAdjust = 0.123;
    preset == 1 ? gainAdjust = 0.282;
     // RIAA
    preset == 2 ?
  
    (
      filter1.eqPK(srate,   250, 0.9, 2);
      filter2.eqHP(srate,    20, 0.9);
      filter3.eqLP(srate, 16000, 0.15);
      filter4.eqPK(srate,  5000, 0.6, 4);
      filter5.eqPK(srate,  1000, 0.6, 3);
      
      gainAdjust = 0.5;   
      
    );  
      
    // Update state flag
    lastPreset = preset;
  );
  
@sample
  
  // Generate noise based on selected preset
  preset == 0 ? spl0 = tickWhite();
  preset == 1 ? spl0 = tickPink();
  preset >= 2 ? spl0 = tickFiltered();
  
  // Apply trim gain to signal and copy to 2nd output channel
  spl0 *= gainAdjust;
  spl1  = spl0;
